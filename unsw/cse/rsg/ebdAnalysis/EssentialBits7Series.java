/*
 * Copyright (c) 2010-2011 Brigham Young University
 * 
 * This file is part of the BYU RapidSmith Tools.
 * 
 * BYU RapidSmith Tools is free software: you may redistribute it 
 * and/or modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 * 
 * BYU RapidSmith Tools is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * A copy of the GNU General Public License is included with the BYU 
 * RapidSmith Tools. It can be found at doc/gpl2.txt. You may also 
 * get a copy of the license at <http://www.gnu.org/licenses/>.
 * 
 */
package unsw.cse.rsg.ebdAnalysis;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import edu.byu.ece.rapidSmith.bitstreamTools.bitstream.Bitstream;
import edu.byu.ece.rapidSmith.bitstreamTools.bitstream.BitstreamParseException;
import edu.byu.ece.rapidSmith.bitstreamTools.bitstream.BitstreamParser;
import edu.byu.ece.rapidSmith.bitstreamTools.configuration.FPGA;
import edu.byu.ece.rapidSmith.bitstreamTools.configuration.Frame;
import edu.byu.ece.rapidSmith.bitstreamTools.configuration.FrameAddressRegister;
import edu.byu.ece.rapidSmith.bitstreamTools.configuration.FrameData;
import edu.byu.ece.rapidSmith.bitstreamTools.configurationSpecification.BlockSubType;
import edu.byu.ece.rapidSmith.bitstreamTools.configurationSpecification.DeviceLookup;
import edu.byu.ece.rapidSmith.bitstreamTools.configurationSpecification.S7MaskConfigurationSpecification;
import edu.byu.ece.rapidSmith.bitstreamTools.configurationSpecification.XilinxConfigurationSpecification;

public class EssentialBits7Series {
	
	    // Nested class 
		static class FrameExtended extends Frame
		{
			// Logical frame Addressing. First Frame Address (FRAD) starts with 0, second with 1, etc. 0,1,2,..N 
			private int LA;
			
			public FrameExtended(int frameSize, int frameAddress)
			{	
				super(frameSize, frameAddress);
				this.setLA(0);
			}
			
			public FrameExtended(int frameSize)
			{	
				super(frameSize, 0);
				this.setLA(0);
			}
			
			public void setFrameAddress(int frameAddress) {
				super.frameAddress = frameAddress;
			}

			public int getLA() {
				return LA;
			}

			public void setLA(int lA) {
				LA = lA;
			}
		}
		
		private String bitstreamPath = "";
		/* The ebd file is generated by the Xilinx bitgen tool when the essential bits generation is enabled. 
		* It is a ascii mask of the readbackfile of the FPGA. 0s represent non-essential bits while 1s the essential bits.*/
		private String ebdFilePath = "";
		
		/* The ebc file is generated by the Xilinx bitgen tool when the essential bits generation is enabled. 
		*  It is data of all frames in ascii. Similar to the readbackfile without any overhead. */
		private String ebcFilePath = "";
		
		private XilinxConfigurationSpecification spec;
		private FPGA fpga;
		private int FRAME_SIZE_BITS, FRAME_SIZE_WORDS, ROWS_TOP, ROWS_BOTTOM = 0;
		private List<BlockSubType> COLUMN_FRAMES = null;
		
		/*There are 4 type of FRAD. In the bistream  we usually encouneter type 1 frames for configuration of the primitives (sclices, dsps, bram , pips etc.)
		end type 1. Type2, 3, 4 are never found in the bitstream. However, they can be found when we readback the FPGA and include essential bits.
		For example the Artix-7 200t include 600 of type 3 and 4 frames. In literature these frames are not scrubbed. However, SEM and 
		the internal readback SEU correction circuit of the 5, 6, and 7 series FPGAs scrub these frames. For more information read the thesis
		"Configuration Scrubbing Architectures for High-Reliability FPGA Systems", http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=6703&context=etd
		*/
		private int sensitiveBitsType1 = 0; // type1 sensitive bits
		private int sensitiveBitsType234 = 0; // type2, 3, 4 sensitive bits	
		
		private ArrayList<FrameExtended> ebcFrames;
		private ArrayList<FrameExtended> ebdFrames;
		
		private HashMap<Integer, FrameData> hashMapEbdFrames;
		private HashMap<Integer, FrameData> hashMapEbcFrames;
		
		private ArrayList<Integer> fpgaFrameAddresses;
		
		
		public EssentialBits7Series(String bitstreamPath, String ebdFilePath, String ebcFilePath) {
			this.bitstreamPath = bitstreamPath;
			this.ebcFilePath = ebcFilePath;
			this.ebdFilePath = ebdFilePath;
			this.configureFPGA();
			this.analyzeData();
		}
		
		public ArrayList<Integer> getFpgaFrameAddresses() {
			return this.fpgaFrameAddresses;
		}
		
		public int getSensitiveBitsType1() {
			return this.sensitiveBitsType1;
		}
		
		public int getSensitiveBitsType234() {
			return this.sensitiveBitsType234;
		}
		
		public String getBitstreamPath() {
			return this.bitstreamPath;
		}
		
		public String getEbcFilePath() {
			return this.ebcFilePath;
		}
		
		public String getEbdFilePath() {
			return this.ebdFilePath;
		}
		
		public ArrayList<FrameExtended> getEbcFrames() {
			return this.ebcFrames;
		}
			
		public HashMap<Integer, FrameData>  getHashMapEbdFrames() {
			return this.hashMapEbdFrames;
		}
		
		public HashMap<Integer, FrameData>  getHashMapEbcFrames() {
			return this.hashMapEbcFrames;
		}
		
		
		public int countEbdBits(ArrayList<Integer> frameAddresses) {
			int count = 0;
			for(Integer frameAddress : frameAddresses) {
				count += hashMapEbdFrames.get(frameAddress).countBitsSet();
			}
			return count;
		}
		
		public FrameData getFrameDataFromEbd(Integer frameAddress) {
			return hashMapEbdFrames.get(frameAddress);		
		}
		
		// Create a map of the ebc or ebd frames. Key = frame address, Value = ebd or ebc Frame Data  
		private HashMap<Integer, FrameData> getHashMapEbdFrameData(ArrayList<FrameExtended> ebcEbdFrames) {
			HashMap<Integer, FrameData> hashMapEbdEbcFrames = new HashMap<>();
			for(FrameExtended frame : ebcEbdFrames){
				hashMapEbdEbcFrames.put(frame.getFrameAddress(), frame.getData());
			}
			return hashMapEbdEbcFrames;
		}
		
		
		
		// Create a map of the sensitive frames. Key = frame address, Value = List with sensitive bit positions in the frame.  
		public HashMap<Integer, ArrayList<Integer>> getSenitiveFrames() {
			HashMap<Integer, ArrayList<Integer>> sensitiveFrames = new HashMap<>();
			
			for(FrameExtended frame : ebdFrames){
				FrameData frameData = frame.getData();
				ArrayList<Integer> sensitiveBits = new ArrayList<>();
				for(int i = 0; i < frameData.size(); i++) {
					if( frameData.getBit(i) == 1) {
						sensitiveBits.add(i);
					}	
				}
				sensitiveFrames.put(frame.getFrameAddress(), sensitiveBits);
			}
			return sensitiveFrames;
		}
		
		
		public void printResults() {
			System.out.println("Type 1 sensitive bits = " + sensitiveBitsType1);	
			System.out.println("Type 2, 3 and 4 sensitive bits = " + sensitiveBitsType234 );	
			System.out.println("All sensitive bits = " + (sensitiveBitsType1 + sensitiveBitsType234));
			
		}
		
		/**
		 * Method used to configure the FPGA class with the bitstream.    
		 */
		private void configureFPGA(){
			Bitstream bitstream = null;
			try {
				bitstream = BitstreamParser.parseBitstream(bitstreamPath);
			} catch (BitstreamParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			spec = DeviceLookup.lookupPartV4V5V6S7withPackageName(bitstream.getHeader().getPartName());
			fpga = new FPGA(spec);
			fpga.configureBitstream(bitstream);
			FRAME_SIZE_BITS  = spec.getFrameSize() * 32;
			FRAME_SIZE_WORDS = spec.getFrameSize();
			ROWS_TOP = spec.getTopNumberOfRows();
			ROWS_BOTTOM = spec.getBottomNumberOfRows();
			COLUMN_FRAMES = spec.getOverallColumnLayout();
		}
		
		
		/**
		 * @param  an list with string 0s or 1s from ebd or ebc files.
		 * @return a list with FrameExtended class instantiations (frame address and frame data) of the ebd or ebc file.      
		 */
		private ArrayList<FrameExtended> getEbdEbcFrames(ArrayList<String> ebdEbcArray){
			//delete header in the ebdArray or ebcArray
			ebdEbcArray.subList(0, 8).clear();
			//create a list to store the frames from the ebd and ebc files
			ArrayList<FrameExtended> frames = new ArrayList<>();
			
			// number of frames in the ebc or ebd files
			int numberOfFrames = (ebdEbcArray.size() * 32) / FRAME_SIZE_BITS;
			
			//read word by word the ebd or ebc ascii data, convert them in binary, configure the FrameExtended class and add the frame to a list
			for(int la = 0; la < numberOfFrames; la++) {
				FrameExtended frame = new FrameExtended(FRAME_SIZE_WORDS);
				frame.setLA(la);
				String data = "";
				for (int i = 0 + (la * FRAME_SIZE_WORDS); i < FRAME_SIZE_WORDS + (la * FRAME_SIZE_WORDS); i++) {
					data += ebdEbcArray.get(i);
				}
				FrameData frameData = getFrameData(data);
				frame.configure(frameData);
				frames.add(frame);
			}				
			return frames;
		}
		
		
		/**
		 * @param  A string with ascii 0s or 1s of the ebd or ebc files
		 * @return Configured FrameData class with binary data from the String frameBitsASCI
		 */
		private FrameData getFrameData(String frameBitsASCI)
	    {
	        List<Byte> framesData = new ArrayList<Byte>();
	        byte[] frameBits = frameBitsASCI.getBytes();
	        byte b;
	        int bitIndex;
	        int byteIndex = 0;
	        int val;
	    	for (byteIndex = 0; byteIndex < frameBits.length; byteIndex += 8)
	        {
	            b = 0;
	            for (bitIndex = 0; bitIndex < 8; bitIndex++)
	            {
	                val = (frameBits[byteIndex + bitIndex] - 0x30) << (7 - bitIndex);
	                b   |= (byte)(val);
	            }
	            framesData.add((Byte)b);
	        }
	    	FrameData f = new FrameData(framesData);
	        return f;
	    }
		
		
		/**
		 * @param  the path of the ebd or ebc file
		 * @return An array with strings. Each entry of the array is one line of the 
		 * ebc or ebd file without the newline character            
		 */
		private ArrayList<String> readFile(String path){
			ArrayList<String> lines = new ArrayList<>();
			String line = "";
			File f = new File(path);
			BufferedReader b;
			try {

	            b = new BufferedReader(new FileReader(f));
	            while ((line = b.readLine()) != null) {               
	            	lines.add(line.replace("\n", "").replace("\r", ""));
	            }

	        } catch (IOException e) {
	            e.printStackTrace();
	        }	
			return lines;
		}
	
		
		private void analyzeData() {
			// read the ebd file
			ArrayList<String> ebdArray = readFile(ebdFilePath);
			// read the ebc file
			ArrayList<String> ebcArray = readFile(ebcFilePath);
			
			// create a list with FrameExtended instantiations with data from the ebd and ebc files. 
			// Easier to manipulate this information 
			ebcFrames = getEbdEbcFrames(ebcArray);
			ebdFrames = getEbdEbcFrames(ebdArray);

			FrameData ebdFrameData = null;
			FrameData ebcFrameData  = null;
			FrameData bitstreamData = null;
			
			FrameAddressRegister far = new FrameAddressRegister(spec);
			fpgaFrameAddresses = new ArrayList<>();
			
			// skip the first frame --> DUMMY
			int index = 1; 
			
			// for the top and bottom of the FPGA
			for(int h = 0; h <= 1; h++) {
				int rows = 0;
				
				// the number of rows on the top or bottom can be different.
				if(h == 0){
					rows = ROWS_TOP;
				} else {
					rows = ROWS_BOTTOM;
				}
				
				// for all rows on the top or bottom
				for(int r = 0; r < rows; r++) {
					// for all columns in the row
					for(int c = 0; c < COLUMN_FRAMES.size(); c++){
						int m = 0;
						
						// for all frames in the column (i.e. minor frames) 
						for(; m < COLUMN_FRAMES.get(c).getFramesPerConfigurationBlock(); m++) {	
							
							// construct the FAR for 7 series.
							far.setFAR(getFrameAddress(0, h, r, c, m));
							fpgaFrameAddresses.add(far.getAddress());
							
							// get the data of the particular frame from the bitstream
							bitstreamData = fpga.getFrame(far).getData();
							
							// get the data of the particular frame from the ebc file
							ebcFrameData = ebcFrames.get(index).getData();
							
							// check if they are equal. We do this in order to be sure that we extract the correct information from the ebc file and the corresponding ebd file.
							// The ebc and ebd files do not have any FAR data. They contain only the configuration of the frames, just like when we readback the bistream from the FPGA.
							if ( bitstreamData.isEqual(ebcFrameData) ) {
								ebdFrameData = ebdFrames.get(index).getData();			
								
								ebcFrames.get(index).setLA(index);
								ebdFrames.get(index).setLA(index);							
								ebcFrames.get(index).setFrameAddress(getFrameAddress(0, h, r, c, m));
								ebdFrames.get(index).setFrameAddress(getFrameAddress(0, h, r, c, m));
								
								sensitiveBitsType1 += ebdFrameData.countBitsSet();
								index++;
							// if the data for the ebc file and the bistream are not the same, we re-adjust the indexes of the ebc, ebd files. 
							} else {
								System.out.println("EBC frame != BitstreamFrame. Probably it is a DUMMY or Type 2, 3, 4 frame");
								System.out.println("TOP = " + far.getTopBottom() + " ROW = " + far.getRow() + " COLUMN = " + far.getColumn() + " MINOR = " + far.getMinor());
								System.out.println("EBC current index = " + index);
								int indexNew = findIndexEbc(bitstreamData);
								sensitiveBitsType234 += countBitsEbd(index, indexNew);
								System.out.println("Adjusting ebc and ebd index = " + indexNew);
								index = indexNew;
								ebcFrameData = ebcFrames.get(index).getData();
								if ( bitstreamData.isEqual(ebcFrameData) ) {
									ebdFrameData = ebdFrames.get(index).getData();

									ebcFrames.get(index).setLA(index);
									ebdFrames.get(index).setLA(index);							
									ebcFrames.get(index).setFrameAddress(getFrameAddress(0, h, r, c, m));
									ebdFrames.get(index).setFrameAddress(getFrameAddress(0, h, r, c, m));
									
									sensitiveBitsType1 += ebdFrameData.countBitsSet();
									index++;
								// Abord the ebd and ebc analysis if the data if the ebc and bitstream are different even after re-adjusting the indexes of the ebc, ebd files. 
								} else {
									System.out.println("Error: Can't find the correct index in the ebc file");
									System.exit(0);
								}
							}
						}
					}
				}
			}		
			
			sensitiveBitsType234 += countBitsEbd(index-1, ebdFrames.size() );
			
			hashMapEbdFrames = getHashMapEbdFrameData(ebdFrames);
			hashMapEbcFrames = getHashMapEbdFrameData(ebcFrames);
		}
		
		// 7 series FAR mask
		private int getFrameAddress(int blockType, int topBottom, int row, int column, int minor){
			int frameAddress = 
			  (blockType << S7MaskConfigurationSpecification.S7_BLOCK_TYPE_BIT_POS) 
			| (topBottom << S7MaskConfigurationSpecification.S7_TOP_BOTTOM_BIT_POS) 
			| (row << S7MaskConfigurationSpecification.S7_ROW_BIT_POS) 
			| (column << S7MaskConfigurationSpecification.S7_COLUMN_BIT_POS) 
			| (minor << S7MaskConfigurationSpecification.S7_MINOR_BIT_POS) ;
			
			return frameAddress;
		}
		
		
		//Find the given FrameData in the ebc file. Return the index of the ebc data or -1 when not found  
		private  int findIndexEbc(FrameData frameDataBitstream) {
			for(int i = 0; i < ebcFrames.size(); i++) {
				FrameData frameDataEbc = ebcFrames.get(i).getData();
				if(frameDataBitstream.isEqual(frameDataEbc)) {
					return i;
				}
			}
			return -1;
		}
		
		//Count the number of essential bits in the following range of the arraylist 
		private int countBitsEbd(int startIndex, int stopIndex) {
			int count = 0;
			for(int i = startIndex; i < stopIndex; i++) {
				FrameData frameDataEbd = ebdFrames.get(i).getData();
				count += frameDataEbd.countBitsSet();
			}
			return count;
		}

}
